<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Radar UI</title>
<style>
  html, body {
    margin: 0;
    background: #0b140b;
    height: 100%;
  }

  canvas {
    display: block;
    margin: auto;
    background: radial-gradient(circle at 50% 70%, #0f2a12, #081008 100%);
  }
  
  .permission-notice {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 20, 0, 0.8);
    color: #6dff6d;
    padding: 15px;
    border: 2px solid #6dff6d;
    border-radius: 5px;
    font-family: monospace;
    text-align: center;
    z-index: 100;
    display: none;
  }
</style>
</head>
<body>

<div class="permission-notice" id="permissionNotice">
  <h3>⚠️ Device Orientation Required</h3>
  <p>Allow compass access to see the geo-locked radar dot.</p>
  <p>This requires HTTPS connection.</p>
</div>

<canvas id="radar"></canvas>

<script>

const canvas = document.getElementById("radar");
const ctx = canvas.getContext("2d");
const permissionNotice = document.getElementById("permissionNotice");

// --- 16:9 ---
canvas.width = 1280;
canvas.height = 720;

// ===== ADDED: Green dots array =====
const greenDots = []; // Stores {x, y, life} for each dot

// ===== ADDED: ROLL EFFECT STATE =====
let isRolling = false;
let rollOffset = 0;
let rollSpeed = 30;
let rollCount = 0;
let maxRolls = 5; // Total number of rolls
let lastRollTime = 0; // Timer for 5-minute intervals

// ===== ADDED: STARTUP ANIMATION STATE =====
let startupPhase = 0; // 0 = black screen, 1 = line appears, 2 = stretch from middle, 3 = full reveal
let startupProgress = 0;
let startupLineHeight = 2;
let startupTimer = 0;

// ===== ADDED: WARP EFFECT STATE =====
let lastWarpTime = 0;
let warpActive = false;
let warpProgress = 0;
let warpX = 0, warpY = 0, warpStrength = 0, warpDuration = 0;
let warpsThisCycle = 0;
let warpsDone = 0;

// ===== ADDED: GEO-LOCKED DOT STATE =====
let geoDot = {
  active: false,
  x: 0,
  y: 0,
  radius: 8,
  color: "#32ff32", // Changed to green (non-pulsing)
  glowColor: "rgba(50, 255, 50, 0.3)", // Green glow
  direction: 0, // 0° = North, 90° = East, 180° = South, 270° = West
  distance: 0.4, // 0-1, distance from center (0.4 = 40% from center)
  pulse: 0,
  pulseSpeed: 0.05,
  visibleInRadar: true // Track if dot is within radar area
};

// ===== ADDED: BORDER HIGHLIGHT STATE =====
let borderHighlights = {
  left: false,
  right: false,
  bottom: false,
  intensity: 0
};

let deviceOrientation = {
  available: false,
  alpha: 0, // Compass direction (0-360)
  beta: 0,  // Front-back tilt
  gamma: 0  // Left-right tilt
};
// ====================================

// ===== ADDED: Temporary canvas for roll effect =====
const tempCanvas = document.createElement('canvas');
tempCanvas.width = canvas.width;
tempCanvas.height = canvas.height;
const tempCtx = tempCanvas.getContext('2d');
// ===================================================

// ===== ADDED: Click handler for radar dots =====
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  // Add a green dot where clicked (starts with full life, fades out)
  greenDots.push({
    x: x,
    y: y,
    life: 100 // 100% opacity, fades to 0
  });
});
// ============================================

// ===== ADDED: DEVICE ORIENTATION HANDLER =====
function initDeviceOrientation() {
  if (window.DeviceOrientationEvent) {
    // Check for iOS 13+ permission
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
      permissionNotice.style.display = 'block';
      
      // Try to request permission on user interaction
      const requestPermission = () => {
        DeviceOrientationEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === 'granted') {
              window.addEventListener('deviceorientation', handleOrientation);
              deviceOrientation.available = true;
              geoDot.active = true;
              permissionNotice.style.display = 'none';
            }
          })
          .catch(console.error);
      };
      
      // Request on any click
      document.addEventListener('click', requestPermission, { once: true });
      permissionNotice.innerHTML += '<p><button onclick="requestPermission()">Click to Enable Compass</button></p>';
      window.requestPermission = requestPermission;
    } else {
      // Non-iOS 13+ devices
      window.addEventListener('deviceorientation', handleOrientation);
      deviceOrientation.available = true;
      geoDot.active = true;
    }
  } else {
    console.log("Device orientation not supported");
    // Fallback: Use mouse position to simulate direction
    setupMouseOrientation();
  }
}

function handleOrientation(event) {
  if (event.alpha !== null) {
    deviceOrientation.alpha = event.alpha; // Compass direction
    deviceOrientation.beta = event.beta;   // Front-back tilt
    deviceOrientation.gamma = event.gamma; // Left-right tilt
    
    // Update geo dot direction based on compass
    geoDot.direction = deviceOrientation.alpha;
    
    // Update geo dot position and visibility
    updateGeoDotPosition();
  }
}

function setupMouseOrientation() {
  // Fallback for desktop: mouse position controls direction
  let mouseX = 0;
  let mouseY = 0;
  
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
    
    // Calculate angle from center to mouse
    const centerX = canvas.width / 2;
    const centerY = canvas.height * 0.72; // apexY
    const dx = mouseX - centerX;
    const dy = mouseY - centerY;
    
    // Convert to compass angle (0° = North, clockwise)
    let angle = Math.atan2(dy, dx) * (180 / Math.PI);
    angle = (angle + 90) % 360; // Adjust so 0° = up (North)
    if (angle < 0) angle += 360;
    
    geoDot.direction = angle;
    updateGeoDotPosition();
    geoDot.active = true;
  });
}

function updateGeoDotPosition() {
  const cx = canvas.width / 2;
  const apexY = canvas.height * 0.72;
  const radius = canvas.height * 0.62;
  
  // Convert compass direction to canvas radians
  // Canvas: 0° = right, 90° = down
  // Compass: 0° = North = canvas -90°
  const canvasAngle = (geoDot.direction - 90) * (Math.PI / 180);
  
  // Calculate position based on direction and distance
  geoDot.x = cx + Math.cos(canvasAngle) * radius * geoDot.distance;
  geoDot.y = apexY + Math.sin(canvasAngle) * radius * geoDot.distance;
  
  // ===== ADDED: SIMPLIFIED RADAR VISIBILITY CHECK =====
  // Convert compass direction to a simple classification
  const dir = geoDot.direction;
  
  // Define radar coverage area in compass degrees
  // Radar faces forward (north), covering about 90° forward
  const radarStart = 315; // 315° = NW
  const radarEnd = 45;    // 45° = NE
  
  // Check if direction is within radar coverage
  let inRadar = false;
  
  if (radarStart < radarEnd) {
    // Normal case
    inRadar = (dir >= radarStart || dir <= radarEnd);
  } else {
    // Wrap around case
    inRadar = (dir >= radarStart || dir <= radarEnd);
  }
  
  geoDot.visibleInRadar = inRadar;
  
  // ===== FIXED: SIMPLE COMPASS-BASED BORDER LOGIC =====
  // Reset all highlights
  borderHighlights.left = false;
  borderHighlights.right = false;
  borderHighlights.bottom = false;
  
  // Update highlight intensity based on dot position
  if (!geoDot.visibleInRadar) {
    // Classify direction into sectors
    // North: 0° (but this is in radar)
    // East: 90°
    // South: 180° 
    // West: 270°
    
    // Check which sector the direction is in
    if ((dir > 45 && dir <= 135) || (dir >= 225 && dir < 315)) {
      // Directions between 45-135° (E/SE) or 225-315° (W/NW)
      // These are to the sides
      if (dir >= 225 && dir < 315) {
        // West side (225-315°)
        borderHighlights.left = true;
      } else {
        // East side (45-135°)
        borderHighlights.right = true;
      }
    } else {
      // Directions between 135-225° (S/SW/SE)
      // This is behind (south)
      borderHighlights.bottom = true;
    }
    
    // Increase intensity when dot is outside radar
    borderHighlights.intensity = Math.min(1, borderHighlights.intensity + 0.1);
  } else {
    // Fade out intensity when dot is inside radar
    borderHighlights.intensity = Math.max(0, borderHighlights.intensity - 0.05);
  }
}
// =============================================

// ===== ADDED: Main draw function =====
function drawEverything() {
  // Clear canvas with black (for startup effect)
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // ===== ADDED: CCTV STARTUP ANIMATION - STRETCH FROM MIDDLE =====
  if (startupPhase < 3) {
    startupTimer++;
    
    if (startupPhase === 0) {
      // Phase 0: Complete black screen for a moment - FASTER
      if (startupTimer > 5) { // 0.25 seconds instead of 0.5
        startupPhase = 1;
        startupTimer = 0;
      }
    } 
    else if (startupPhase === 1) {
      // Phase 1: Single horizontal line appears in middle - FASTER
      ctx.fillStyle = '#6dff6d';
      startupLineHeight = Math.min(startupLineHeight + 1.5, 2); // Faster growth
      ctx.fillRect(0, canvas.height/2 - startupLineHeight/2, canvas.width, startupLineHeight);
      
      if (startupTimer > 8) { // 0.5 seconds instead of 1
        startupPhase = 2;
        startupTimer = 0;
        startupProgress = 0;
      }
    }
    else if (startupPhase === 2) {
      // Phase 2: STRETCH FROM MIDDLE (unsquash effect) - MUCH FASTER
      startupProgress = Math.min(startupProgress + 0.05, 1); // 3x faster
      
      // Calculate stretch effect
      const centerY = canvas.height / 2;
      const visibleHeight = canvas.height * startupProgress;
      const topY = centerY - (visibleHeight / 2);
      
      // Draw stretched/unsquashed content
      ctx.save();
      
      // Create a "stretch" transformation
      // Scale from middle: content starts squished at line, expands outward
      const stretchFactor = startupProgress;
      
      // Calculate the visible portion
      const sourceY = centerY - (canvas.height * (1 - stretchFactor) / 2);
      const sourceHeight = canvas.height * stretchFactor;
      
      // Draw the radar UI with stretch effect
      ctx.save();
      ctx.translate(0, topY);
      ctx.scale(1, stretchFactor);
      
      // Draw the full radar UI scaled
      drawRadarUI();
      ctx.restore();
      
      // Draw the expanding green line borders with stretch glow
      ctx.fillStyle = '#6dff6d';
      const glowAlpha = 0.3 * (1 - startupProgress);
      ctx.fillStyle = `rgba(109, 255, 109, ${glowAlpha})`;
      ctx.fillRect(0, topY - 10, canvas.width, 10);
      ctx.fillRect(0, topY + visibleHeight, canvas.width, 10);
      
      // Bright center line
      ctx.fillStyle = '#6dff6d';
      ctx.fillRect(0, centerY - 1, canvas.width, 2);
      
      // Add scan line effect during stretch
      if (Math.random() > 0.7) {
        for(let i = 0; i < 3; i++) {
          const scanY = centerY + (Math.random() - 0.5) * visibleHeight * 0.8;
          const scanAlpha = Math.random() * 0.4;
          ctx.fillStyle = `rgba(109, 255, 109, ${scanAlpha})`;
          ctx.fillRect(0, scanY, canvas.width, 1);
        }
      }
      
      if (startupProgress >= 1) {
        startupPhase = 3;
        startupTimer = 0;
        // Draw one final flash/transition
        ctx.fillStyle = 'rgba(109, 255, 109, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }
    
    // Continue animation
    requestAnimationFrame(drawEverything);
    return; // Stop here until startup is complete
  }
  // =========================================
  
  // ===== ADDED: Start roll every 5 minutes =====
  const now = Date.now();
  
  // Initialize timer on first run
  if (!lastRollTime) {
    lastRollTime = now + 5000; // Start 5 seconds after startup
  }
  
  // Check if 5 minutes have passed since last roll ENDED
  if (!isRolling && (now - lastRollTime > 300000)) { // 300,000ms = 5 minutes
    isRolling = true;
    rollOffset = 0;
    rollCount = 0;
    rollSpeed = 30;
    // Timer will be updated when roll finishes
  }
  // =====================================
  
  // Draw the full radar UI
  drawRadarUI();
  
  // ===== ADDED: Continue animation =====
  requestAnimationFrame(drawEverything);
}

// ===== ADDED: Separate function to draw radar UI =====
function drawRadarUI() {
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // --- Scan lines ---
  ctx.fillStyle = 'rgba(0,0,0,2)';
  for (let y = 0; y < canvas.height; y += 5) {
    ctx.fillRect(0, y, canvas.width, .8);
  }
  
  // ===== ADDED: PULSING static effect =====
  const staticTimer = Date.now() / 1000;
  const pulse = Math.sin(staticTimer * 2) * 0.5 + 0.5;

  if (pulse > 0.3) {
    const intensity = pulse;
    const numParticles = Math.floor(30 * intensity);
    
    for(let i = 0; i < numParticles; i++) {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      const size = Math.random() * 3 + 1;
      const alpha = Math.random() * 0.3 * intensity;
      
      ctx.fillStyle = `rgba(120, 255, 120, ${alpha})`;
      ctx.fillRect(x, y, size, size);
    }
  }

  // Vertical jitter effect
  if (Math.random() > 0.97) {
    const jitterAmount = Math.random() * 4 - 2;
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    ctx.putImageData(imageData, 0, jitterAmount);
  }

  // === GAPPED CIRCLE - INVERSE GAPS, START AT TOP ===
  const circleX = canvas.width / 2;
  const circleY = canvas.height * 0.71;
  const circleRadius = 110;
  const lineWidth = 45;

  const visibleSegments = [
    [232, 315],   // left Bottom,Top left
    [45, 130],    // Right Top, 
    [137, 225],   // Bottom Right,Bottom left
  ];

  // ===== MODIFIED: Draw border segments with highlight effect =====
  visibleSegments.forEach(([startDeg, endDeg], index) => {
    const startRad = ((startDeg - 90) * Math.PI / 180);
    const endRad = ((endDeg - 90) * Math.PI / 180);
    
    // Determine if this segment should be highlighted
    let isHighlighted = false;
    let highlightIntensity = 0;
    
    // Left segment (index 0: 232-315 degrees)
    if (index === 0 && borderHighlights.left) {
      isHighlighted = true;
      highlightIntensity = borderHighlights.intensity;
    }
    // Right segment (index 1: 45-130 degrees)
    else if (index === 1 && borderHighlights.right) {
      isHighlighted = true;
      highlightIntensity = borderHighlights.intensity;
    }
    // Bottom segment (index 2: 137-225 degrees)
    else if (index === 2 && borderHighlights.bottom) {
      isHighlighted = true;
      highlightIntensity = borderHighlights.intensity;
    }
    
    if (isHighlighted && highlightIntensity > 0) {
      // FIXED: Use green color progression instead of pink
      // Interpolate from light green (#6dff6d) to solid green (#32ff32)
      const baseR = 109; // #6dff6d
      const baseG = 255;
      const baseB = 109;
      
      const targetR = 50;  // #32ff32
      const targetG = 255;
      const targetB = 50;
      
      // Interpolate based on intensity
      const r = Math.round(baseR + (targetR - baseR) * highlightIntensity);
      const g = Math.round(baseG + (targetG - baseG) * highlightIntensity);
      const b = Math.round(baseB + (targetB - baseB) * highlightIntensity);
      
      // Draw highlighted version
      ctx.lineWidth = lineWidth + (10 * highlightIntensity);
      ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.3 + 0.7 * highlightIntensity})`;
      
      // Draw glow effect
      ctx.shadowBlur = 20 * highlightIntensity;
      ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${0.7 * highlightIntensity})`;
    } else {
      // Draw normal version
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = "rgba(109, 255, 109, 0.3)";
      ctx.shadowBlur = 0;
    }
    
    ctx.lineCap = 'butt';
    
    if (endDeg < startDeg) {
      ctx.beginPath();
      ctx.arc(circleX, circleY, circleRadius, startRad, Math.PI * 2);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.arc(circleX, circleY, circleRadius, 0, endRad);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.arc(circleX, circleY, circleRadius, startRad, endRad);
      ctx.stroke();
    }
    
    // Reset shadow for next drawings
    ctx.shadowBlur = 0;
  });

  // === END GAPPED CIRCLE ===

  // --- Layout anchors ---
  const cx = canvas.width / 2;
  const apexY = canvas.height * 0.72;
  const radius = canvas.height * 0.62;
  const startAngle = -Math.PI * 0.73;
  const endAngle   = -Math.PI * 0.27;

  // --- Colors ---
  const green = "#6dff6d";
  const faint = "rgba(120,255,120,0.25)";
  const veryFaint = "rgba(120,255,120,0.12)";

  // --- Helper ---
  function polar(r, a) {
    return {
      x: cx + r * Math.cos(a),
      y: apexY + r * Math.sin(a)
    };
  }

  // --- Outer arc ---
  ctx.strokeStyle = green;
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.arc(cx, apexY, radius, startAngle + 0.015, endAngle - 0.015);
  ctx.stroke();

  // --- Inner/Lower arc ---
  ctx.strokeStyle = green;
  ctx.lineWidth = 1;
  const lowerRadius = radius - 10;
  ctx.beginPath();
  ctx.arc(cx, apexY, lowerRadius, startAngle + 0.015, endAngle - 0.015);
  ctx.stroke();

  // --- Side beams ---
  ctx.lineWidth = 3;
  [startAngle, endAngle].forEach(a => {
    const p = polar(radius, a);
    ctx.beginPath();
    ctx.moveTo(cx, apexY);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();
  });

  // --- Center vertical line ---
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(cx, apexY);
  ctx.lineTo(cx, apexY - radius * 1.03);
  ctx.stroke();

  // --- Inner radial dividers ---
  [-0.48, +0.48].forEach(t => {
    const a = startAngle + (endAngle - startAngle) * (t + 1) / 2;
    const p = polar(radius * 1.03, a);
    ctx.beginPath();
    ctx.moveTo(cx, apexY);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();
  });

  // --- Dashed range arcs ---
  ctx.setLineDash([15, 30]);
  ctx.lineWidth = 1.5;
  [0.35, 0.55, 0.75].forEach(r => {
    ctx.beginPath();
    ctx.arc(cx, apexY, radius * r, startAngle + 0.03, endAngle - 0.03);
    ctx.stroke();
  });
  ctx.setLineDash([]);

  // ===== ADDED: Draw green dots where clicked =====
  for (let i = greenDots.length - 1; i >= 0; i--) {
    const dot = greenDots[i];
    
    dot.life -= 1.5;
    
    if (dot.life > 0) {
      ctx.fillStyle = `rgba(109, 255, 109, ${dot.life/100})`;
      ctx.beginPath();
      ctx.arc(dot.x, dot.y, 6, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = `rgba(109, 255, 109, ${dot.life/200})`;
      ctx.beginPath();
      ctx.arc(dot.x, dot.y, 10, 0, Math.PI * 2);
      ctx.fill();
    } else {
      greenDots.splice(i, 1);
    }
  }

  // --- Left buttons ---
  ctx.fillStyle = "#32ff32";
  ctx.fillRect(cx - radius * 0.65, apexY + 20, 70, 40);
  ctx.fillRect(cx - radius * 0.65, apexY + 80, 48, 40);

  ctx.fillStyle = "#0b140b";
  ctx.font = "28px monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("1", cx - radius * 0.63 + 50, apexY + 44);
  ctx.fillText("2", cx - radius * 0.63 + 24, apexY + 104);

  // --- Right labels ---
  ctx.fillStyle = green;
  ctx.font = "Bold 26px monospace";
  ctx.textAlign = "left";
  ["ATT", "SUS", "DEC"].forEach((t, i) => {
    ctx.fillText(t, cx + radius * 0.55, apexY + 35 + i * 36);
  });

  // ===== MODIFIED: DRAW GEO-LOCKED DOT ONLY IF WITHIN RADAR AREA =====
  if (geoDot.active && geoDot.visibleInRadar) {
    // Draw glow (static, not pulsing)
    ctx.fillStyle = geoDot.glowColor;
    ctx.beginPath();
    ctx.arc(geoDot.x, geoDot.y, geoDot.radius * 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw main dot (static, not pulsing)
    ctx.fillStyle = geoDot.color;
    ctx.beginPath();
    ctx.arc(geoDot.x, geoDot.y, geoDot.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw direction indicator line
    const lineLength = 20;
    const lineAngle = (geoDot.direction - 90) * (Math.PI / 180);
    const endX = geoDot.x + Math.cos(lineAngle) * lineLength;
    const endY = geoDot.y + Math.sin(lineAngle) * lineLength;
    
    ctx.strokeStyle = "#32ff32";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(geoDot.x, geoDot.y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
  }
  // =====================================

  // ===== ADDED: MAGNETIC WARP EFFECT (1-4 times every 5 minutes) =====
  const now = Date.now();
  
  // Initialize warp timer on first run
  if (!lastWarpTime) {
    lastWarpTime = now;
    warpsThisCycle = Math.floor(Math.random() * 20) + 15; // 1-4 warps
  }
  
  // Check if 5 minutes have passed for warp cycle
  if (!warpActive && warpsDone < warpsThisCycle && (now - lastWarpTime > 300000)) {
    warpActive = true;
    warpProgress = 0;
    warpX = Math.random() * canvas.width;
    warpY = Math.random() * canvas.height;
    warpStrength = Math.random() * 80 + 40; // 40-120 strength (intense!)
    warpDuration = Math.random() * 60 + 40; // 40-100 frames per warp
  }
  
  // Handle active warp
  if (warpActive) {
    warpProgress++;
    
    // Calculate warp intensity with smooth in/out
    let intensity = 0;
    if (warpProgress < warpDuration * 0.3) {
      intensity = (warpProgress / (warpDuration * 0.3)); // Ramp up
    } else if (warpProgress < warpDuration * 0.7) {
      intensity = 1; // Full intensity
    } else {
      intensity = 1 - ((warpProgress - warpDuration * 0.7) / (warpDuration * 0.3)); // Ramp down
    }
    
    // Apply the warp distortion
    const currentStrength = warpStrength * intensity;
    
    // Save current state
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const tempData = ctx.createImageData(canvas.width, canvas.height);
    
    // Apply warp distortion
    for(let y = 0; y < canvas.height; y++) {
      for(let x = 0; x < canvas.width; x++) {
        const dx = x - warpX;
        const dy = y - warpY;
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        // Strong warp effect
        const warpAmount = currentStrength / (distance + 10);
        const srcX = Math.max(0, Math.min(canvas.width-1, x + dx * warpAmount * 0.015));
        const srcY = Math.max(0, Math.min(canvas.height-1, y + dy * warpAmount * 0.015));
        
        const srcIdx = (Math.floor(srcY) * canvas.width + Math.floor(srcX)) * 4;
        const dstIdx = (y * canvas.width + x) * 4;
        
        // Add color distortion near the center
        if (distance < 150) {
          const colorDistort = 1 + (currentStrength / 300) * (1 - distance/150);
          tempData.data[dstIdx] = Math.min(255, data[srcIdx] * colorDistort); // Red
          tempData.data[dstIdx+1] = Math.min(255, data[srcIdx+1] * (colorDistort * 0.7)); // Green less
          tempData.data[dstIdx+2] = Math.min(255, data[srcIdx+2] * (colorDistort * 1.3)); // Blue more
          tempData.data[dstIdx+3] = data[srcIdx+3];
        } else {
          tempData.data[dstIdx] = data[srcIdx];
          tempData.data[dstIdx+1] = data[srcIdx+1];
          tempData.data[dstIdx+2] = data[srcIdx+2];
          tempData.data[dstIdx+3] = data[srcIdx+3];
        }
      }
    }
    
    // Apply the warp
    ctx.putImageData(tempData, 0, 0);
    
    // Visual effects for warp center
    ctx.fillStyle = `rgba(255, 50, 50, ${intensity * 0.6})`;
    ctx.beginPath();
    ctx.arc(warpX, warpY, 8 + intensity * 25, 0, Math.PI * 2);
    ctx.fill();
    
    // Distortion rings
    ctx.strokeStyle = `rgba(255, 100, 100, ${intensity * 0.4})`;
    ctx.lineWidth = 1 + intensity;
    for(let i = 1; i <= 3; i++) {
      const radius = i * 60 + intensity * 40;
      ctx.beginPath();
      ctx.arc(warpX, warpY, radius, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // End this warp
    if (warpProgress >= warpDuration) {
      warpActive = false;
      warpsDone++;
      
      // If we've done all warps for this cycle, reset
      if (warpsDone >= warpsThisCycle) {
        lastWarpTime = now;
        warpsDone = 0;
        warpsThisCycle = Math.floor(Math.random() * 4) + 1; // New random count
      }
    }
  }
  // =============================================================

  // ===== ADDED: SIMPLE ROLL EFFECT THAT WORKS =====
  if (isRolling) {
    // Save current frame to temp canvas
    tempCtx.clearRect(0, 0, canvas.width, canvas.height);
    tempCtx.drawImage(canvas, 0, 0);
    
    // Clear main canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Update roll position
    rollOffset += rollSpeed;
    
    // Check if completed one full roll
    if (rollOffset >= canvas.height) {
      rollOffset = 0;
      rollCount++;
      
      // After 4 fast rolls, slow down on the 5th roll
      if (rollCount >= 4) {
        rollSpeed *= 0.7;
      }
      
      // If completed 5 rolls OR slowed to stop
      if (rollCount >= maxRolls || rollSpeed < 1) {
        isRolling = false;
        rollOffset = 0;
        rollCount = 0;
        rollSpeed = 30; // Reset speed
        lastRollTime = Date.now(); // UPDATE TIMER WHEN ROLL FINISHES
        
        // Draw final frame normally
        ctx.drawImage(tempCanvas, 0, 0);
        return;
      }
    }
    
    // Draw the rolled/scrolled image
    // This creates the wrap-around effect:
    // Part 1: Bottom part of image goes to top
    ctx.drawImage(tempCanvas, 
      0, canvas.height - rollOffset, // Source: bottom part
      canvas.width, rollOffset,      // Source dimensions
      0, 0,                          // Destination: top
      canvas.width, rollOffset       // Destination dimensions
    );
    
    // Part 2: Top part of image goes to bottom
    ctx.drawImage(tempCanvas, 
      0, 0,                          // Source: top part  
      canvas.width, canvas.height - rollOffset, // Source dimensions
      0, rollOffset,                 // Destination: bottom
      canvas.width, canvas.height - rollOffset  // Destination dimensions
    );
    
    // Add scan lines during roll
    ctx.strokeStyle = rollCount < 4 ? 'rgba(255, 50, 50, 0.6)' : 'rgba(120, 255, 120, 0.4)';
    ctx.lineWidth = 2;
    
    // Draw moving scan lines
    for(let i = 0; i < 3; i++) {
      const lineY = (rollOffset + i * 50) % canvas.height;
      ctx.beginPath();
      ctx.moveTo(0, lineY);
      ctx.lineTo(canvas.width, lineY);
      ctx.stroke();
    }
    
    // Add VHS tracking distortion at the seam
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(0, rollOffset - 2, canvas.width, 4);
  }
}

// ===== ADDED: Initialize device orientation =====
initDeviceOrientation();
// ================================================

// ===== ADDED: Start animation =====
drawEverything();
// ===================================

</script>
</body>
</html>
